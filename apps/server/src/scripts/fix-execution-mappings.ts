#!/usr/bin/env tsx
/**
 * Standalone script to fix execution event mappings
 * Run with: npx tsx fix-execution-mappings.ts
 */

import db from "@/db";
import * as schema from "@/db/schema";
import { eq, sql, and } from "drizzle-orm";

async function fixExecutionEventMappings() {
  console.log("=== FIXING EXECUTION EVENT MAPPINGS ===\n");

  try {
    // Step 1: Check current state
    console.log("Step 1: Analyzing current state...");
    
    const [currentState] = await db.execute(sql`
      SELECT 
        COUNT(CASE WHEN da.module_type = 'execution' THEN 1 END)::int as execution_activities,
        COUNT(CASE WHEN da.module_type = 'execution' AND cem.id IS NOT NULL THEN 1 END)::int as mapped_execution,
        COUNT(CASE WHEN da.module_type = 'planning' THEN 1 END)::int as planning_activities,
        COUNT(CASE WHEN da.module_type = 'planning' AND cem.id IS NOT NULL THEN 1 END)::int as mapped_planning,
        COUNT(cem.id)::int as total_mappings
      FROM dynamic_activities da
      LEFT JOIN configurable_event_mappings cem ON da.id = cem.activity_id AND cem.is_active = true
    `);

    const state = currentState as any;
    console.log("Current state:");
    console.log(`  - Execution activities: ${state.execution_activities}`);
    console.log(`  - Mapped execution activities: ${state.mapped_execution}`);
    console.log(`  - Planning activities: ${state.planning_activities}`);
    console.log(`  - Mapped planning activities: ${state.mapped_planning}`);
    console.log(`  - Total mappings: ${state.total_mappings}`);
    
    const unmappedExecution = state.execution_activities - state.mapped_execution;
    console.log(`  - Unmapped execution activities: ${unmappedExecution}\n`);

    if (unmappedExecution === 0) {
      console.log("âœ… All execution activities already have event mappings. Nothing to fix!");
      return;
    }

    // Step 2: Find GOODS_SERVICES event
    console.log("Step 2: Finding GOODS_SERVICES event...");
    
    const goodsServicesEvents = await db
      .select({ id: schema.events.id, code: schema.events.code })
      .from(schema.events)
      .where(eq(schema.events.code, 'GOODS_SERVICES'));

    if (goodsServicesEvents.length === 0) {
      console.error("âŒ GOODS_SERVICES event not found!");
      
      console.log("\nAvailable events:");
      const allEvents = await db
        .select({ id: schema.events.id, code: schema.events.code })
        .from(schema.events)
        .orderBy(schema.events.code);
      allEvents.forEach(event => console.log(`  - ${event.code} (ID: ${event.id})`));
      return;
    }

    const goodsServicesEventId = goodsServicesEvents[0].id;
    console.log(`âœ… Found GOODS_SERVICES event (ID: ${goodsServicesEventId})\n`);

    // Step 3: Get unmapped execution activities
    console.log("Step 3: Finding unmapped execution activities...");
    
    const unmappedActivities = await db
      .select({ 
        id: schema.dynamicActivities.id, 
        name: schema.dynamicActivities.name,
        projectType: schema.dynamicActivities.projectType,
        facilityType: schema.dynamicActivities.facilityType,
        categoryId: schema.dynamicActivities.categoryId
      })
      .from(schema.dynamicActivities)
      .leftJoin(
        schema.configurableEventMappings,
        and(
          eq(schema.configurableEventMappings.activityId, schema.dynamicActivities.id),
          eq(schema.configurableEventMappings.isActive, true)
        )
      )
      .where(
        and(
          eq(schema.dynamicActivities.moduleType, 'execution'),
          sql`${schema.configurableEventMappings.id} IS NULL`
        )
      );

    console.log(`Found ${unmappedActivities.length} unmapped execution activities`);
    
    if (unmappedActivities.length === 0) {
      console.log("âœ… No unmapped execution activities found!");
      return;
    }

    console.log("Sample unmapped activities:");
    unmappedActivities.slice(0, 5).forEach(activity => {
      console.log(`  - ${activity.name} (${activity.projectType}, ${activity.facilityType})`);
    });
    console.log();

    // Step 4: Create mappings
    console.log("Step 4: Creating event mappings...");
    
    const mappingRows = unmappedActivities.map(activity => ({
      eventId: goodsServicesEventId,
      activityId: activity.id,
      categoryId: activity.categoryId,
      projectType: activity.projectType,
      facilityType: activity.facilityType,
      mappingType: 'DIRECT' as const,
      mappingFormula: null,
      mappingRatio: '1.0000',
      isActive: true,
      effectiveFrom: null,
      effectiveTo: null,
      metadata: {
        autoGenerated: true,
        mappingDescription: 'Direct mapping from execution activity to GOODS_SERVICES event',
        moduleType: 'execution',
        fixedAt: new Date().toISOString(),
        fixScript: 'standalone'
      },
    }));

    console.log(`Inserting ${mappingRows.length} mappings...`);

    // Use direct insertion with proper error handling
    const insertResult = await db
      .insert(schema.configurableEventMappings)
      .values(mappingRows)
      .returning({ id: schema.configurableEventMappings.id });

    console.log(`âœ… Successfully inserted ${insertResult.length} mappings\n`);

    // Step 5: Verify the fix
    console.log("Step 5: Verifying the fix...");
    
    const [finalState] = await db.execute(sql`
      SELECT 
        COUNT(CASE WHEN da.module_type = 'execution' THEN 1 END)::int as execution_activities,
        COUNT(CASE WHEN da.module_type = 'execution' AND cem.id IS NOT NULL THEN 1 END)::int as mapped_execution,
        COUNT(cem.id)::int as total_mappings
      FROM dynamic_activities da
      LEFT JOIN configurable_event_mappings cem ON da.id = cem.activity_id AND cem.is_active = true
    `);

    const final = finalState as any;
    console.log("Final state:");
    console.log(`  - Execution activities: ${final.execution_activities}`);
    console.log(`  - Mapped execution activities: ${final.mapped_execution}`);
    console.log(`  - Total mappings: ${final.total_mappings}`);
    
    const remainingUnmapped = final.execution_activities - final.mapped_execution;
    console.log(`  - Remaining unmapped: ${remainingUnmapped}`);

    if (remainingUnmapped === 0) {
      console.log("\nðŸŽ‰ SUCCESS! All execution activities now have event mappings!");
    } else {
      console.log(`\nâš ï¸  Still have ${remainingUnmapped} unmapped execution activities`);
    }

    // Step 6: Show mapping summary
    console.log("\nStep 6: Mapping summary by project type:");
    
    const summary = await db.execute(sql`
      SELECT 
        da.project_type,
        da.facility_type,
        COUNT(da.id)::int as activities,
        COUNT(cem.id)::int as mappings
      FROM dynamic_activities da
      LEFT JOIN configurable_event_mappings cem ON da.id = cem.activity_id AND cem.is_active = true
      WHERE da.module_type = 'execution'
      GROUP BY da.project_type, da.facility_type
      ORDER BY da.project_type, da.facility_type
    `);

    (summary as any[]).forEach(row => {
      console.log(`  ${row.project_type} ${row.facility_type}: ${row.mappings}/${row.activities} mapped`);
    });

    console.log("\nâœ… Fix completed successfully!");

  } catch (error) {
    console.error("\nâŒ Error fixing execution event mappings:", error);
    process.exit(1);
  }
}

// Run the fix
if (require.main === module) {
  fixExecutionEventMappings()
    .then(() => {
      console.log("\nScript completed successfully!");
      process.exit(0);
    })
    .catch((error) => {
      console.error("\nScript failed:", error);
      process.exit(1);
    });
}

export default fixExecutionEventMappings;